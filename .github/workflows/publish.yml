name: Publish to npm

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version-dispatch.outputs.version || steps.version-release.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync with remote (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "üîÑ Fetching latest changes from remote..."
          DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d" " -f5 || echo "")
          if [ -z "$DEFAULT_BRANCH" ]; then
            for branch in main master; do
              if git ls-remote --heads origin $branch | grep -q .; then
                DEFAULT_BRANCH=$branch
                break
              fi
            done
          fi
          if [ -z "$DEFAULT_BRANCH" ]; then
            DEFAULT_BRANCH="main"
          fi
          echo "üîÑ Using branch: $DEFAULT_BRANCH"
          git fetch origin $DEFAULT_BRANCH || true
          CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
          if [ -z "$CURRENT_BRANCH" ] || [ "$CURRENT_BRANCH" != "$DEFAULT_BRANCH" ]; then
            git checkout $DEFAULT_BRANCH || true
          fi
          git pull origin $DEFAULT_BRANCH --rebase || git pull origin $DEFAULT_BRANCH || true

      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Bump version (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        id: version-dispatch
        shell: bash
        run: |
          LOCAL_VERSION=$(node -p "require('./package.json').version")
          echo "üì¶ Local package.json version: $LOCAL_VERSION"

          NPM_VERSION=$(npm view node-plantuml-2 version 2>/dev/null || echo "")

          if [ -z "$NPM_VERSION" ]; then
            echo "üì¶ No existing version on npm, starting fresh"
            BASE_VERSION=$LOCAL_VERSION
          else
            echo "üì¶ Latest npm version: $NPM_VERSION"

            COMPARE=$(node -e "
              const local = '$LOCAL_VERSION'.split('.').map(Number);
              const npm = '$NPM_VERSION'.split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                if (local[i] > npm[i]) {
                  console.log('local');
                  process.exit(0);
                } else if (local[i] < npm[i]) {
                  console.log('npm');
                  process.exit(0);
                }
              }
              console.log('equal');
            ")

            if [ "$COMPARE" = "npm" ] || [ "$COMPARE" = "equal" ]; then
              echo "‚ö†Ô∏è  npm version ($NPM_VERSION) is newer or equal to local ($LOCAL_VERSION)"
              npm version $NPM_VERSION --no-git-tag-version --allow-same-version
              BASE_VERSION=$NPM_VERSION
            else
              echo "‚úÖ Local version ($LOCAL_VERSION) is newer than npm ($NPM_VERSION)"
              BASE_VERSION=$LOCAL_VERSION
            fi
          fi

          CURRENT=$(node -p "require('./package.json').version")
          if [ "$CURRENT" != "$BASE_VERSION" ]; then
            npm version $BASE_VERSION --no-git-tag-version --allow-same-version
          fi

          echo "üÜï Incrementing version (${{ github.event.inputs.version }})..."
          npm version ${{ github.event.inputs.version }} --no-git-tag-version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "üÜï New version: $NEW_VERSION"

          if npm view node-plantuml-2@$NEW_VERSION version > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Version $NEW_VERSION already exists, incrementing again..."
            npm version ${{ github.event.inputs.version }} --no-git-tag-version
            NEW_VERSION=$(node -p "require('./package.json').version")

            if npm view node-plantuml-2@$NEW_VERSION version > /dev/null 2>&1; then
              echo "‚ùå Error: Version $NEW_VERSION also exists on npm"
              exit 1
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Bump version (release)
        if: github.event_name == 'release'
        id: version-release
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "Release version: $VERSION"

          if npm view node-plantuml-2@$VERSION version > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Warning: Version $VERSION already exists on npm"
          fi

          npm version $VERSION --no-git-tag-version --allow-same-version
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "‚úÖ Version set: $VERSION"

      - name: Verify version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "üì¶ Version to publish: $VERSION"
          echo "‚úÖ Version ready"

      - name: Download PlantUML JAR
        shell: bash
        run: |
          echo "üì• Downloading PlantUML JAR (will be shared with other jobs)..."
          node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
        continue-on-error: true

      - name: Upload PlantUML JAR as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vendor-files
          path: |
            vendor/plantuml.jar
            vendor/**
          retention-days: 1

  build-and-publish-runtimes:
    needs: prepare
    strategy:
      matrix:
        include:
          - platform: linux
            arch: x64
            runner: ubuntu-latest
            package: '@node-plantuml-2/jre-linux-x64'
          - platform: win32
            arch: x64
            runner: windows-latest
            package: '@node-plantuml-2/jre-win32-x64'
          - platform: darwin
            arch: arm64
            runner: macos-14
            package: '@node-plantuml-2/jre-darwin-arm64'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Verify Java installation
        shell: bash
        run: |
          echo "Java version:"
          java -version
          echo ""
          echo "JAVA_HOME: $JAVA_HOME"
          echo ""
          echo "Checking jlink..."
          if [ -f "$JAVA_HOME/bin/jlink" ]; then
            echo "‚úì jlink found at: $JAVA_HOME/bin/jlink"
            "$JAVA_HOME/bin/jlink" --version
          elif command -v jlink &> /dev/null; then
            echo "‚úì jlink found in PATH"
            jlink --version
          else
            echo "‚ùå Error: jlink not found in JAVA_HOME/bin or PATH"
            exit 1
          fi

      - name: Install dependencies
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Download PlantUML JAR from artifact
        id: download-vendor
        uses: actions/download-artifact@v4
        if: always()
        with:
          name: vendor-files
          path: vendor/
          merge-multiple: true

      - name: Download PlantUML JAR (fallback if artifact missing)
        shell: bash
        if: steps.download-vendor.outcome == 'failure'
        run: |
          echo "üì• Artifact not available - Downloading PlantUML JAR (fallback)..."
          node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
        continue-on-error: true

      - name: Verify PlantUML JAR exists
        shell: bash
        run: |
          if [ ! -f "vendor/plantuml.jar" ]; then
            echo "üì• PlantUML JAR not found - Downloading..."
            node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
          else
            echo "‚úì PlantUML JAR found"
          fi
        continue-on-error: true

      - name: Create runtime directory
        shell: bash
        run: |
          mkdir -p runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}

      - name: Create package.json for runtime
        shell: bash
        run: |
          echo "üìù Creating package.json for ${{ matrix.package }}..."
          node scripts/create-runtime-package-json.js ${{ matrix.platform }} ${{ matrix.arch }} ${{ needs.prepare.outputs.version }}

      - name: Build JRE
        shell: bash
        run: |
          echo "üî® Building JRE for ${{ matrix.platform }} ${{ matrix.arch }}..."
          echo "JAVA_HOME: $JAVA_HOME"
          # Ensure JAVA_HOME is available for the Node.js script
          export JAVA_HOME="$JAVA_HOME"
          node scripts/build-jre.js ${{ matrix.platform }} ${{ matrix.arch }}

      - name: Verify JRE
        shell: bash
        run: |
          if [ "${{ matrix.platform }}" = "win32" ]; then
            JAVA_EXE="runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}/jre/bin/java.exe"
          else
            JAVA_EXE="runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}/jre/bin/java"
          fi
          
          if [ ! -f "$JAVA_EXE" ]; then
            echo "‚ùå Error: JRE executable not found at $JAVA_EXE"
            exit 1
          fi
          
          echo "‚úì JRE executable found"
          
          # Verify Java works
          if [ "${{ matrix.platform }}" = "win32" ]; then
            "$JAVA_EXE" -version
          else
            chmod +x "$JAVA_EXE"
            "$JAVA_EXE" -version
          fi
          
          echo "‚úÖ JRE verification passed"

      - name: Test JRE with PlantUML
        shell: bash
        continue-on-error: true
        run: |
          echo "üß™ Testing JRE with PlantUML..."
          if [ "${{ matrix.platform }}" = "win32" ]; then
            JAVA_EXE="runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}/jre/bin/java.exe"
            PLANTUML_JAR="vendor/plantuml.jar"
            TEST_CODE="@startuml
            A -> B
            @enduml"
            
            echo "$TEST_CODE" | "$JAVA_EXE" -Djava.awt.headless=true -jar "$PLANTUML_JAR" -pipe -tpng > test-output.png || {
              echo "‚ö†Ô∏è  PlantUML test failed, but continuing..."
              exit 0
            }
            
            if [ -f test-output.png ] && [ -s test-output.png ]; then
              echo "‚úì PlantUML test passed ($(wc -c < test-output.png) bytes)"
              rm -f test-output.png
            else
              echo "‚ö†Ô∏è  PlantUML test output is empty, but continuing..."
            fi
          else
            JAVA_EXE="runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}/jre/bin/java"
            PLANTUML_JAR="vendor/plantuml.jar"
            TEST_CODE="@startuml
            A -> B
            @enduml"
            
            chmod +x "$JAVA_EXE"
            echo "$TEST_CODE" | "$JAVA_EXE" -Djava.awt.headless=true -jar "$PLANTUML_JAR" -pipe -tpng > test-output.png || {
              echo "‚ö†Ô∏è  PlantUML test failed, but continuing..."
              exit 0
            }
            
            if [ -f test-output.png ] && [ -s test-output.png ]; then
              echo "‚úì PlantUML test passed ($(wc -c < test-output.png) bytes)"
              rm -f test-output.png
            else
              echo "‚ö†Ô∏è  PlantUML test output is empty, but continuing..."
            fi
          fi

      - name: Verify NPM authentication
        shell: bash
        run: |
          echo "üîç Verifying npm authentication..."
          npm whoami || {
            echo "‚ùå Error: Not authenticated to npm"
            exit 1
          }
          echo "‚úÖ Successfully authenticated to npm"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Check npm organization exists
        shell: bash
        run: |
          echo "üîç Checking if npm organization @node-plantuml-2 exists..."
          
          # Try to check if the organization scope exists by attempting to view a non-existent package
          # If scope doesn't exist, npm will return "Scope not found"
          ERROR_OUTPUT=$(npm view @node-plantuml-2/jre-linux-x64@999.0.0 2>&1 || true)
          
          if echo "$ERROR_OUTPUT" | grep -q "Scope not found"; then
            echo ""
            echo "‚ùå ERROR: npm organization @node-plantuml-2 does not exist!"
            echo ""
            echo "üìù You must create the npm organization before publishing runtime packages."
            echo ""
            echo "   Quick setup (choose one method):"
            echo ""
            echo "   Method 1 (Web UI - Recommended):"
            echo "   1. Go to: https://www.npmjs.com/org/create"
            echo "   2. Create organization: node-plantuml-2"
            echo "   3. Choose 'Public' (free for public packages)"
            echo "   4. Make sure your npm account is the owner"
            echo ""
            echo "   Method 2 (Command line):"
            echo "   npm org create node-plantuml-2"
            echo ""
            echo "   After creating:"
            echo "   - Ensure your NPM_TOKEN has access to publish to the organization"
            echo "   - You may need to regenerate your NPM_TOKEN with organization permissions"
            echo ""
            echo "   For detailed instructions, see: docs/NPM_ORGANIZATION_SETUP.md"
            echo ""
            exit 1
          elif echo "$ERROR_OUTPUT" | grep -q "not in this registry\|404"; then
            # Package doesn't exist, but scope exists - this is OK
            echo "‚úÖ npm organization @node-plantuml-2 exists (package not found is expected)"
          else
            echo "‚ö†Ô∏è  Could not definitively verify organization, but continuing..."
            echo "   If publish fails with 'Scope not found', please check docs/NPM_ORGANIZATION_SETUP.md"
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        continue-on-error: false

      - name: Check if runtime package version exists
        id: check-version
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          if npm view ${{ matrix.package }}@$VERSION version > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Version $VERSION already exists for ${{ matrix.package }}"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Version $VERSION is available for ${{ matrix.package }}"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        continue-on-error: true

      - name: Publish runtime package
        if: steps.check-version.outputs.exists != 'true'
        shell: bash
        run: |
          echo "üì¶ Publishing ${{ matrix.package }}@${{ needs.prepare.outputs.version }}..."
          cd runtimes/@node-plantuml-2/jre-${{ matrix.platform }}-${{ matrix.arch }}
          npm publish --access public
          echo "‚úÖ Published ${{ matrix.package }}@${{ needs.prepare.outputs.version }}"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Publish runtime package (skip if exists)
        if: steps.check-version.outputs.exists == 'true'
        shell: bash
        run: |
          echo "‚ÑπÔ∏è  Version ${{ needs.prepare.outputs.version }} already exists for ${{ matrix.package }}, skipping publish"

  build-and-publish-graphviz:
    needs: prepare
    strategy:
      matrix:
        include:
          - platform: linux
            arch: x64
            runner: ubuntu-latest
            package: '@node-plantuml-2/graphviz-linux-x64'
          - platform: win32
            arch: x64
            runner: windows-latest
            package: '@node-plantuml-2/graphviz-win32-x64'
          - platform: darwin
            arch: arm64
            runner: macos-14
            package: '@node-plantuml-2/graphviz-darwin-arm64'
          - platform: darwin
            arch: x64
            runner: macos-14
            package: '@node-plantuml-2/graphviz-darwin-x64'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install Graphviz (for building package)
        shell: bash
        run: |
          echo "üì¶ Installing Graphviz for package building..."
          if [ "${{ matrix.platform }}" = "darwin" ]; then
            # macOS: Install via Homebrew
            if ! command -v brew &> /dev/null; then
              echo "Installing Homebrew..."
              /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            if [ -f /opt/homebrew/bin/brew ]; then
              export PATH="/opt/homebrew/bin:$PATH"
            fi
            brew install graphviz || brew upgrade graphviz
          elif [ "${{ matrix.platform }}" = "linux" ]; then
            # Linux: Install via apt-get
            sudo apt-get update
            sudo apt-get install -y graphviz
          elif [ "${{ matrix.platform }}" = "win32" ]; then
            # Windows: Try Chocolatey or Winget
            if command -v choco &> /dev/null; then
              choco install graphviz -y
            elif command -v winget &> /dev/null; then
              winget install Graphviz.Graphviz --accept-package-agreements --accept-source-agreements
            else
              echo "‚ö†Ô∏è  Please install Graphviz manually on Windows"
            fi
          fi

      - name: Verify Graphviz installation
        shell: bash
        run: |
          echo "Verifying Graphviz installation..."
          if [ "${{ matrix.platform }}" = "win32" ]; then
            where dot || echo "dot not found"
            dot -V || echo "dot command failed"
          else
            which dot || echo "dot not found"
            dot -V || echo "dot command failed"
          fi

      - name: Install dependencies
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Create Graphviz package directory
        shell: bash
        run: |
          mkdir -p runtimes/@node-plantuml-2/graphviz-${{ matrix.platform }}-${{ matrix.arch }}

      - name: Create package.json for Graphviz runtime
        shell: bash
        run: |
          echo "üìù Creating package.json for ${{ matrix.package }}..."
          node scripts/create-graphviz-package-json.js ${{ matrix.platform }} ${{ matrix.arch }} ${{ needs.prepare.outputs.version }}

      - name: Build Graphviz package
        shell: bash
        run: |
          echo "üî® Building Graphviz package for ${{ matrix.platform }} ${{ matrix.arch }}..."
          if node scripts/build-graphviz.js ${{ matrix.platform }} ${{ matrix.arch }}; then
            echo "‚úÖ Build step completed successfully"
          else
            echo "‚ùå Build step failed with exit code: $?"
            exit 1
          fi

      - name: List build output directory
        shell: bash
        run: |
          echo "üìÅ Listing build output directory..."
          PACKAGE_DIR="runtimes/@node-plantuml-2/graphviz-${{ matrix.platform }}-${{ matrix.arch }}"
          echo "Checking directory: $PACKAGE_DIR"
          echo "Current working directory: $(pwd)"
          echo ""
          
          if [ -d "$PACKAGE_DIR" ]; then
            echo "‚úÖ Package directory exists: $PACKAGE_DIR"
            echo "Contents of package directory:"
            ls -la "$PACKAGE_DIR" || echo "Failed to list package directory"
            echo ""
            
            if [ -d "$PACKAGE_DIR/graphviz" ]; then
              echo "‚úÖ Graphviz directory exists"
              echo "Contents of graphviz directory:"
              ls -la "$PACKAGE_DIR/graphviz" || echo "Failed to list graphviz directory"
              echo ""
              
              if [ -d "$PACKAGE_DIR/graphviz/bin" ]; then
                echo "‚úÖ Bin directory exists"
                echo "Contents of bin directory:"
                ls -la "$PACKAGE_DIR/graphviz/bin" || echo "Failed to list bin directory"
                echo ""
                
                # Check for dot executable
                if [ "${{ matrix.platform }}" = "win32" ]; then
                  DOT_FILE="$PACKAGE_DIR/graphviz/bin/dot.exe"
                else
                  DOT_FILE="$PACKAGE_DIR/graphviz/bin/dot"
                fi
                
                if [ -f "$DOT_FILE" ]; then
                  echo "‚úÖ Dot executable found: $DOT_FILE"
                  ls -la "$DOT_FILE"
                else
                  echo "‚ùå Dot executable not found: $DOT_FILE"
                fi
              else
                echo "‚ùå Bin directory does not exist: $PACKAGE_DIR/graphviz/bin"
              fi
              
              # Check lib directory (critical for Linux)
              if [ -d "$PACKAGE_DIR/graphviz/lib" ]; then
                echo "‚úÖ Lib directory exists"
                echo "Lib directory contents:"
                ls -la "$PACKAGE_DIR/graphviz/lib" || echo "Failed to list lib directory"
                if [ "${{ matrix.platform }}" == "linux" ]; then
                  LIB_COUNT=$(find "$PACKAGE_DIR/graphviz/lib" -type f \( -name "lib*.so*" -o -name "lib*.so" \) 2>/dev/null | wc -l || echo "0")
                  echo "Found $LIB_COUNT library files"
                  if [ "$LIB_COUNT" -eq 0 ]; then
                    echo "‚ö†Ô∏è  WARNING: No library files found! This will cause runtime errors."
                  else
                    echo "Sample libraries:"
                    find "$PACKAGE_DIR/graphviz/lib" -type f \( -name "lib*.so*" -o -name "lib*.so" \) | head -10 | while read lib; do
                      echo "  - $(basename "$lib")"
                    done
                  fi
                fi
              else
                if [ "${{ matrix.platform }}" == "linux" ]; then
                  echo "‚ùå ERROR: Lib directory does not exist! This will cause runtime errors on Linux."
                else
                  echo "‚ÑπÔ∏è  Lib directory does not exist (may be OK for this platform)"
                fi
              fi
              
              # Calculate and display package size
              PACKAGE_SIZE=$(du -sh "$PACKAGE_DIR/graphviz" 2>/dev/null | cut -f1 || echo "unknown")
              PACKAGE_SIZE_BYTES=$(du -sb "$PACKAGE_DIR/graphviz" 2>/dev/null | cut -f1 || echo "0")
              echo ""
              echo "Package size: $PACKAGE_SIZE ($PACKAGE_SIZE_BYTES bytes)"
              if [ "${{ matrix.platform }}" == "linux" ] && [ "$PACKAGE_SIZE_BYTES" -lt 10485760 ]; then
                echo "‚ö†Ô∏è  WARNING: Package size is less than 10MB, may be missing libraries!"
              fi
            else
              echo "‚ùå Graphviz directory does not exist: $PACKAGE_DIR/graphviz"
            fi
          else
            echo "‚ùå Package directory does not exist: $PACKAGE_DIR"
            echo "Listing parent directory:"
            ls -la runtimes/@node-plantuml-2/ || echo "Parent directory does not exist"
          fi

      - name: Verify Graphviz package
        shell: bash
        run: |
          PACKAGE_DIR="runtimes/@node-plantuml-2/graphviz-${{ matrix.platform }}-${{ matrix.arch }}"
          if [ "${{ matrix.platform }}" = "win32" ]; then
            DOT_EXE="$PACKAGE_DIR/graphviz/bin/dot.exe"
          else
            DOT_EXE="$PACKAGE_DIR/graphviz/bin/dot"
          fi
          
          echo "Checking for dot executable at: $DOT_EXE"
          
          if [ ! -f "$DOT_EXE" ]; then
            echo "‚ùå Error: Graphviz dot executable not found at $DOT_EXE"
            echo "Current directory: $(pwd)"
            echo "Package directory contents:"
            ls -la "$PACKAGE_DIR" || echo "Package directory does not exist"
            if [ -d "$PACKAGE_DIR/graphviz" ]; then
              echo "Graphviz directory contents:"
              ls -la "$PACKAGE_DIR/graphviz" || true
              if [ -d "$PACKAGE_DIR/graphviz/bin" ]; then
                echo "Bin directory contents:"
                ls -la "$PACKAGE_DIR/graphviz/bin" || true
              fi
            fi
            exit 1
          fi
          
          echo "‚úì Graphviz dot executable found"
          
          # Verify executable permissions on Unix
          if [ "${{ matrix.platform }}" != "win32" ]; then
            chmod +x "$DOT_EXE"
            if [ -x "$DOT_EXE" ]; then
              echo "‚úì Dot executable has execute permissions"
            else
              echo "‚ö†Ô∏è  Warning: Dot executable does not have execute permissions"
            fi
          fi
          
          # Verify lib directory exists and contains libraries (critical for Linux)
          if [ "${{ matrix.platform }}" == "linux" ]; then
            LIB_DIR="$PACKAGE_DIR/graphviz/lib"
            if [ -d "$LIB_DIR" ]; then
              echo "‚úì Lib directory exists"
              LIB_COUNT=$(find "$LIB_DIR" -type f \( -name "lib*.so*" -o -name "lib*.so" \) 2>/dev/null | wc -l || echo "0")
              echo "  Found $LIB_COUNT library files"
              if [ "$LIB_COUNT" -eq 0 ]; then
                echo "‚ùå ERROR: No library files found in lib directory!"
                echo "  This will cause runtime errors: 'cannot open shared object file'"
                echo "  Lib directory contents:"
                ls -la "$LIB_DIR" || true
                exit 1
              else
                echo "  Sample libraries:"
                find "$LIB_DIR" -type f \( -name "lib*.so*" -o -name "lib*.so" \) | head -5 | while read lib; do
                  echo "    - $(basename "$lib") ($(du -h "$lib" | cut -f1))"
                done
              fi
            else
              echo "‚ùå ERROR: Lib directory does not exist!"
              echo "  This will cause runtime errors on Linux"
              exit 1
            fi
          fi
          
          # Calculate package size
          PACKAGE_SIZE=$(du -sh "$PACKAGE_DIR/graphviz" 2>/dev/null | cut -f1 || echo "unknown")
          echo "Package size: $PACKAGE_SIZE"
          
          # Warn if package is suspiciously small (Linux should be 20-50MB with libraries)
          # Note: This is a warning, not an error. Actual functionality will be tested in the test step.
          if [ "${{ matrix.platform }}" == "linux" ]; then
            PACKAGE_SIZE_BYTES=$(du -sb "$PACKAGE_DIR/graphviz" 2>/dev/null | cut -f1 || echo "0")
            MIN_EXPECTED_SIZE=$((10 * 1024 * 1024)) # 10MB minimum
            if [ "$PACKAGE_SIZE_BYTES" -lt "$MIN_EXPECTED_SIZE" ]; then
              echo "‚ö†Ô∏è  WARNING: Package size ($PACKAGE_SIZE) is smaller than expected"
              echo "  Expected at least 10MB for Linux package with libraries"
              echo "  Current size: $PACKAGE_SIZE_BYTES bytes"
              echo "  This may indicate missing library files"
              echo "  The package will be tested in the next step to verify functionality"
            else
              echo "‚úì Package size is within expected range"
            fi
          fi
          
          # Verify dot works (with library path for Linux)
          if [ "${{ matrix.platform }}" = "win32" ]; then
            "$DOT_EXE" -V || echo "‚ö†Ô∏è  Warning: dot -V failed (may need DLLs)"
          else
            if [ "${{ matrix.platform }}" == "linux" ] && [ -d "$LIB_DIR" ]; then
              # Set LD_LIBRARY_PATH for testing
              export LD_LIBRARY_PATH="$LIB_DIR:$LD_LIBRARY_PATH"
            fi
            "$DOT_EXE" -V || {
              echo "‚ùå ERROR: dot -V failed"
              if [ "${{ matrix.platform }}" == "linux" ]; then
                echo "  This may indicate missing or incompatible libraries"
                echo "  LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
              fi
              exit 1
            }
          fi
          
          echo "‚úÖ Graphviz package verification passed"

      - name: Test Graphviz package with image generation
        shell: bash
        run: |
          echo "üß™ Testing Graphviz package with image generation..."
          PACKAGE_DIR="runtimes/@node-plantuml-2/graphviz-${{ matrix.platform }}-${{ matrix.arch }}"
          TEST_OUTPUT_DIR="${{ github.workspace }}/test-graphviz-output-${{ matrix.platform }}-${{ matrix.arch }}"
          mkdir -p "$TEST_OUTPUT_DIR"
          
          if [ "${{ matrix.platform }}" = "win32" ]; then
            DOT_EXE="$PACKAGE_DIR/graphviz/bin/dot.exe"
            BIN_DIR="$PACKAGE_DIR/graphviz/bin"
            # Windows uses PATH for DLLs
            if [ -d "$BIN_DIR" ]; then
              export PATH="$BIN_DIR:$PATH"
              echo "Added to PATH: $BIN_DIR"
            fi
          else
            DOT_EXE="$PACKAGE_DIR/graphviz/bin/dot"
            LIB_DIR="$PACKAGE_DIR/graphviz/lib"
            # Set library path for Linux/macOS
            if [ "${{ matrix.platform }}" = "linux" ] && [ -d "$LIB_DIR" ]; then
              export LD_LIBRARY_PATH="$LIB_DIR:$LD_LIBRARY_PATH"
              echo "Set LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
            elif [ "${{ matrix.platform }}" = "darwin" ] && [ -d "$LIB_DIR" ]; then
              export DYLD_LIBRARY_PATH="$LIB_DIR:$DYLD_LIBRARY_PATH"
              echo "Set DYLD_LIBRARY_PATH: $DYLD_LIBRARY_PATH"
            fi
          fi
          
          # Verify dot executable exists and is executable
          if [ ! -f "$DOT_EXE" ]; then
            echo "‚ùå Error: Dot executable not found at $DOT_EXE"
            exit 1
          fi
          
          if [ "${{ matrix.platform }}" != "win32" ]; then
            chmod +x "$DOT_EXE" || true
          fi
          
          echo "Using dot executable: $DOT_EXE"
          
          # Test 1: Simple graph
          echo ""
          echo "Test 1: Simple graph..."
          TEST_GRAPH="digraph G { A -> B; B -> C; }"
          TEST_FILE="$TEST_OUTPUT_DIR/test-1-simple.png"
          TEST_ERROR_FILE="$TEST_OUTPUT_DIR/test-1-error.txt"
          
          # Run dot command and capture both stdout and stderr
          echo "$TEST_GRAPH" | "$DOT_EXE" -Tpng > "$TEST_FILE" 2>"$TEST_ERROR_FILE"
          DOT_EXIT_CODE=$?
          
          if [ $DOT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Test 1 failed: dot command returned error (exit code: $DOT_EXIT_CODE)"
            if [ -f "$TEST_ERROR_FILE" ]; then
              ERROR_SIZE=$(wc -c < "$TEST_ERROR_FILE" || echo "0")
              if [ "$ERROR_SIZE" -gt 0 ]; then
                echo "Error output:"
                cat "$TEST_ERROR_FILE"
                # Check for common dependency errors
                if grep -q "cannot open shared object file\|No such file\|not found\|error while loading shared libraries" "$TEST_ERROR_FILE"; then
                  echo ""
                  echo "‚ö†Ô∏è  This appears to be a missing dependency/library issue"
                  if [ "${{ matrix.platform }}" = "linux" ] && [ -d "$LIB_DIR" ]; then
                    echo "Lib directory: $LIB_DIR"
                    echo "LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
                    echo "Library files in lib directory:"
                    ls -lh "$LIB_DIR" | head -20 || true
                    echo ""
                    echo "Checking ldd output for dot executable:"
                    ldd "$DOT_EXE" 2>&1 | head -30 || true
                  fi
                fi
              else
                echo "No error output captured"
              fi
            fi
            exit 1
          fi
          
          # Check if output file was created and has content
          if [ ! -f "$TEST_FILE" ]; then
            echo "‚ùå Test 1 failed: No output file created"
            exit 1
          fi
          
          if [ ! -s "$TEST_FILE" ]; then
            echo "‚ùå Test 1 failed: Output file is empty"
            if [ -f "$TEST_ERROR_FILE" ] && [ -s "$TEST_ERROR_FILE" ]; then
              echo "Error output:"
              cat "$TEST_ERROR_FILE"
            fi
            exit 1
          fi
          
          # File exists and has content, proceed with validation
          if [ -f "$TEST_FILE" ] && [ -s "$TEST_FILE" ]; then
            SIZE=$(wc -c < "$TEST_FILE" || echo "0")
            if [ "$SIZE" -lt 500 ]; then
              echo "‚ùå Test 1 failed: Image too small ($SIZE bytes)"
              exit 1
            fi
            # Check PNG signature using file command (if available) or simple byte check
            PNG_VALID=false
            if command -v file >/dev/null 2>&1; then
              FILE_TYPE=$(file "$TEST_FILE" 2>/dev/null | grep -i "png\|image" || echo "")
              if [ -n "$FILE_TYPE" ]; then
                PNG_VALID=true
                echo "  PNG signature verified by file command"
              fi
            fi
            
            # If file command didn't confirm, try to check PNG signature manually
            if [ "$PNG_VALID" = false ]; then
              # Simple check: PNG files start with bytes 89 50 4E 47
              # Use a safer method that doesn't cause broken pipe errors
              if command -v od >/dev/null 2>&1; then
                # Read first 4 bytes and check them
                FIRST_BYTES=$(od -An -tx1 -N 4 "$TEST_FILE" 2>/dev/null | tr -d ' \n' || echo "")
                if [ "$FIRST_BYTES" = "89504e47" ] || [ "$FIRST_BYTES" = "89504E47" ]; then
                  PNG_VALID=true
                  echo "  PNG signature verified (0x$FIRST_BYTES)"
                else
                  echo "‚ö†Ô∏è  Warning: PNG signature check failed (got: $FIRST_BYTES, expected: 89504e47)"
                  echo "  But file size is valid, continuing..."
                fi
              elif command -v hexdump >/dev/null 2>&1; then
                FIRST_BYTES=$(hexdump -n 4 -C "$TEST_FILE" 2>/dev/null | head -1 | awk '{print $2$3$4$5}' | tr -d ' ' || echo "")
                if [ "$FIRST_BYTES" = "89504e47" ] || [ "$FIRST_BYTES" = "89504E47" ]; then
                  PNG_VALID=true
                  echo "  PNG signature verified (0x$FIRST_BYTES)"
                else
                  echo "‚ö†Ô∏è  Warning: PNG signature check failed (got: $FIRST_BYTES)"
                  echo "  But file size is valid, continuing..."
                fi
              else
                # Fallback: just check file size and that it's not empty
                echo "‚ö†Ô∏è  Warning: Cannot verify PNG signature (od/hexdump not available)"
                echo "  But file size is valid, assuming PNG is correct"
                PNG_VALID=true
              fi
            fi
            
            if [ "$PNG_VALID" = false ]; then
              echo "‚ö†Ô∏è  Warning: Could not verify PNG signature, but file exists and has valid size"
              echo "  This might indicate an error image, but continuing with test..."
            fi
            echo "‚úì Test 1 passed: $SIZE bytes"
          
          # Test 2: Complex graph with labels
          echo ""
          echo "Test 2: Complex graph with labels..."
          TEST_GRAPH2="digraph G {
            node [shape=box];
            A [label=\"Node A\"];
            B [label=\"Node B\"];
            C [label=\"Node C\"];
            A -> B [label=\"Edge 1\"];
            B -> C [label=\"Edge 2\"];
          }"
          TEST_FILE2="$TEST_OUTPUT_DIR/test-2-complex.png"
          TEST_ERROR_FILE2="$TEST_OUTPUT_DIR/test-2-error.txt"
          
          echo "$TEST_GRAPH2" | "$DOT_EXE" -Tpng > "$TEST_FILE2" 2>"$TEST_ERROR_FILE2"
          DOT_EXIT_CODE=$?
          
          if [ $DOT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Test 2 failed: dot command returned error (exit code: $DOT_EXIT_CODE)"
            if [ -f "$TEST_ERROR_FILE2" ] && [ -s "$TEST_ERROR_FILE2" ]; then
              echo "Error output:"
              cat "$TEST_ERROR_FILE2"
            fi
            exit 1
          fi
          
          if [ ! -f "$TEST_FILE2" ] || [ ! -s "$TEST_FILE2" ]; then
            echo "‚ùå Test 2 failed: No output file or file is empty"
            exit 1
          fi
          
          SIZE=$(wc -c < "$TEST_FILE2" || echo "0")
          if [ "$SIZE" -lt 500 ]; then
            echo "‚ùå Test 2 failed: Image too small ($SIZE bytes)"
            exit 1
          fi
          echo "‚úì Test 2 passed: $SIZE bytes"
          
          # Test 3: SVG output
          echo ""
          echo "Test 3: SVG output..."
          TEST_GRAPH3="digraph G { X -> Y; }"
          TEST_FILE3="$TEST_OUTPUT_DIR/test-3-svg.svg"
          TEST_ERROR_FILE3="$TEST_OUTPUT_DIR/test-3-error.txt"
          
          echo "$TEST_GRAPH3" | "$DOT_EXE" -Tsvg > "$TEST_FILE3" 2>"$TEST_ERROR_FILE3"
          DOT_EXIT_CODE=$?
          
          if [ $DOT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Test 3 failed: dot command returned error (exit code: $DOT_EXIT_CODE)"
            if [ -f "$TEST_ERROR_FILE3" ] && [ -s "$TEST_ERROR_FILE3" ]; then
              echo "Error output:"
              cat "$TEST_ERROR_FILE3"
            fi
            exit 1
          fi
          
          if [ ! -f "$TEST_FILE3" ] || [ ! -s "$TEST_FILE3" ]; then
            echo "‚ùå Test 3 failed: No output file or file is empty"
            exit 1
          fi
          
          SIZE=$(wc -c < "$TEST_FILE3" || echo "0")
          if [ "$SIZE" -lt 200 ]; then
            echo "‚ùå Test 3 failed: SVG too small ($SIZE bytes)"
            exit 1
          fi
          
          # Check SVG signature
          if ! grep -q "<svg" "$TEST_FILE3"; then
            echo "‚ùå Test 3 failed: Invalid SVG format (no <svg> tag found)"
            exit 1
          fi
          echo "‚úì Test 3 passed: $SIZE bytes"
          
          echo ""
          echo "‚úÖ All Graphviz package tests passed!"
          echo "Generated test images:"
          ls -lh "$TEST_OUTPUT_DIR"/* || true

      - name: Upload Graphviz test images as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: graphviz-test-images-${{ matrix.platform }}-${{ matrix.arch }}
          path: test-graphviz-output-${{ matrix.platform }}-${{ matrix.arch }}/*
          if-no-files-found: warn
          retention-days: 7

      - name: Verify NPM authentication
        shell: bash
        run: |
          echo "üîç Verifying npm authentication..."
          npm whoami || {
            echo "‚ùå Error: Not authenticated to npm"
            exit 1
          }
          echo "‚úÖ Successfully authenticated to npm"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Check if Graphviz package version exists
        id: check-version-graphviz
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          if npm view ${{ matrix.package }}@$VERSION version > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Version $VERSION already exists for ${{ matrix.package }}"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Version $VERSION is available for ${{ matrix.package }}"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        continue-on-error: true

      - name: Publish Graphviz runtime package
        if: steps.check-version-graphviz.outputs.exists != 'true'
        shell: bash
        run: |
          echo "üì¶ Publishing ${{ matrix.package }}@${{ needs.prepare.outputs.version }}..."
          cd runtimes/@node-plantuml-2/graphviz-${{ matrix.platform }}-${{ matrix.arch }}
          npm publish --access public
          echo "‚úÖ Published ${{ matrix.package }}@${{ needs.prepare.outputs.version }}"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Publish Graphviz runtime package (skip if exists)
        if: steps.check-version-graphviz.outputs.exists == 'true'
        shell: bash
        run: |
          echo "‚ÑπÔ∏è  Version ${{ needs.prepare.outputs.version }} already exists for ${{ matrix.package }}, skipping publish"

  publish-main:
    needs: [prepare, build-and-publish-runtimes, build-and-publish-graphviz]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true
          ref: ${{ github.event.release.tag_name || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Download PlantUML JAR from artifact
        id: download-vendor
        uses: actions/download-artifact@v4
        if: always()
        with:
          name: vendor-files
          path: vendor/
          merge-multiple: true

      - name: Download PlantUML JAR (fallback if artifact missing)
        shell: bash
        if: steps.download-vendor.outcome == 'failure'
        run: |
          echo "üì• Artifact not available - Downloading PlantUML JAR (fallback)..."
          node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
        continue-on-error: true

      - name: Verify PlantUML JAR exists
        shell: bash
        run: |
          if [ ! -f "vendor/plantuml.jar" ]; then
            echo "üì• PlantUML JAR not found - Downloading..."
            node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
          else
            echo "‚úì PlantUML JAR found"
          fi
        continue-on-error: true

      - name: Update version and optionalDependencies
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "üì¶ Updating main package to version $VERSION"
          
          # Update version
          npm version $VERSION --no-git-tag-version --allow-same-version
          
          # Update optionalDependencies to match runtime package versions
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const version = '$VERSION';
            
            pkg.optionalDependencies = {
              '@node-plantuml-2/jre-win32-x64': '^' + version,
              '@node-plantuml-2/jre-darwin-arm64': '^' + version,
              '@node-plantuml-2/jre-linux-x64': '^' + version,
              '@node-plantuml-2/graphviz-win32-x64': '^' + version,
              '@node-plantuml-2/graphviz-darwin-arm64': '^' + version,
              '@node-plantuml-2/graphviz-darwin-x64': '^' + version,
              '@node-plantuml-2/graphviz-linux-x64': '^' + version
            };
            
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            console.log('‚úÖ Updated optionalDependencies to version ' + version);
          "

      - name: Download PlantUML JAR from artifact
        id: download-vendor-main
        uses: actions/download-artifact@v4
        if: always()
        with:
          name: vendor-files
          path: vendor/
          merge-multiple: true

      - name: Download PlantUML JAR (fallback if artifact missing)
        shell: bash
        if: |
          always() && 
          (steps.download-vendor-main.outcome == 'failure' || 
           !hashFiles('vendor/plantuml.jar'))
        run: |
          echo "üì• Artifact not available - Downloading PlantUML JAR (fallback)..."
          node scripts/get-plantuml-jar.js --latest || echo "JAR download failed, but continuing..."
        continue-on-error: true

      - name: Verify NPM authentication
        run: |
          echo "üîç Verifying npm authentication..."
          npm whoami || {
            echo "‚ùå Error: Not authenticated to npm"
            exit 1
          }
          echo "‚úÖ Successfully authenticated to npm"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Verify version before publish
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "üì¶ Preparing to publish main package version: $VERSION"

          if npm view node-plantuml-2@$VERSION version > /dev/null 2>&1; then
            echo "‚ùå Error: Version $VERSION already exists on npm registry"
            exit 1
          fi

          echo "‚úÖ Version $VERSION is ready to publish"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Publish main package
        run: |
          echo "üì¶ Publishing main package to npm..."
          npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        continue-on-error: false

      - name: Create Git tag and push (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          
          # Add package.json and lock files if they exist
          git add package.json
          [ -f package-lock.json ] && git add package-lock.json || true
          [ -f yarn.lock ] && git add yarn.lock || true
          [ -f pnpm-lock.yaml ] && git add pnpm-lock.yaml || true

          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No changes to commit"
          else
            git commit -m "chore: bump version to $VERSION" || echo "Nothing to commit"
          fi

          echo "üîÑ Pulling latest changes from remote..."
          DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d" " -f5 || echo "")
          if [ -z "$DEFAULT_BRANCH" ]; then
            for branch in main master; do
              if git ls-remote --heads origin $branch | grep -q .; then
                DEFAULT_BRANCH=$branch
                break
              fi
            done
          fi
          if [ -z "$DEFAULT_BRANCH" ]; then
            DEFAULT_BRANCH="main"
          fi
          echo "üîÑ Using branch: $DEFAULT_BRANCH"
          git fetch origin $DEFAULT_BRANCH || true
          git pull origin $DEFAULT_BRANCH --rebase || git pull origin $DEFAULT_BRANCH --no-edit || {
            echo "‚ö†Ô∏è  Warning: Failed to sync with remote, but continuing..."
          }

          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag v$VERSION already exists locally"
          else
            git tag -a "v$VERSION" -m "Release v$VERSION"
          fi

          echo "üì§ Pushing changes to remote..."
          git push origin HEAD:$DEFAULT_BRANCH || {
            echo "‚ùå Failed to push to branch: $DEFAULT_BRANCH"
            exit 1
          }

          if git ls-remote --tags origin | grep -q "refs/tags/v$VERSION$"; then
            echo "‚ÑπÔ∏è  Tag v$VERSION already exists on remote"
          else
            git push origin "v$VERSION" || {
              echo "‚ö†Ô∏è  Failed to push tag, but code was pushed successfully"
            }
          fi

          echo "‚úÖ Successfully pushed version $VERSION"

      - name: Create GitHub Release (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Release v${{ needs.prepare.outputs.version }}
          body: |
            ## Changes in v${{ needs.prepare.outputs.version }}

            See [CHANGELOG.md](CHANGELOG.md) for details.

            ### ‚ú® Features
            - Bundled JRE support (no Java installation required)
            - Multiple output formats (PNG, SVG, EPS, ASCII, Unicode)
            - Full UTF-8 and Chinese character support
            - Platform-specific JRE runtime packages
          draft: false
          prerelease: false
